From fingerle at berlios.de  Fri Jun  9 20:02:20 2006
From: fingerle at berlios.de (fingerle at BerliOS)
Date: Fri, 9 Jun 2006 20:02:20 +0200
Subject: [fellowiki-svncheckins] r19 - in trunk/fellowiki: tests util wiki wiki/tests/tests/simple_markup
Message-ID: <200606091802.k59I2KEl028154@sheep.berlios.de>

Author: fingerle
Date: 2006-06-09 20:02:06 +0200 (Fri, 09 Jun 2006)
New Revision: 19

Added:
   trunk/fellowiki/wiki/tests/
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_invalid.wiki
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_simple.wiki
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_escapes.wiki
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_parms.wiki
Removed:
   trunk/fellowiki/tests/wiki/
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros.wiki
Modified:
   trunk/fellowiki/util/assorted.py
   trunk/fellowiki/wiki/parser.py
Log:
- moved wiki tests to wiki directory
- switched unit tests to nosetests
- wiki parser: much work on macros, but unfinished


Modified: trunk/fellowiki/util/assorted.py
===================================================================
--- trunk/fellowiki/util/assorted.py	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/util/assorted.py	2006-06-09 18:02:06 UTC (rev 19)
@@ -59,6 +59,38 @@
     pattern = re.compile(r'\\(.)') # TODO: don't recompile everytime around
     return pattern.sub(r'\1', string)
     
+    
+def remove_backslashes_and_whitespace(string):
+    """remove escaping backslashes and enclosing whitespace
+    
+    parameters: string: escaped string, may be unicode as well
+    returns: unescaped version of the string
+    
+    This function looks for any occurence of "\." where "." can be any
+    single character and replaces it by the character "." itself.
+    
+    Additionally it removes all enclosing whitespace (i.e. blank and
+    tab) which hadn't been escaped before.
+    
+    """
+    
+    string = string.lstrip(' \t')
+    
+    pattern = re.compile(r'(\\)(?=[ \t]*$)') # TODO: don't recompile everytime around
+    string2 = pattern.sub(r'\\\\', string)
+    
+    if len(string) == len(string2):
+        return remove_escaping_backslashes(string).rstrip(' \t')
+    
+    string = remove_escaping_backslashes(string)
+    string2 = remove_escaping_backslashes(string2)
+    
+    if len(string) == len(string2):
+        return string.rstrip(' \t')
+    else:
+        pattern = re.compile(r'([ \t])[ \t]*$') # TODO: don't recompile everytime around
+        return pattern.sub(r'\1', string)
+    
 def save_add(val_1, val_2):
     """add to values, None being a neutral element to the addition
     

Modified: trunk/fellowiki/wiki/parser.py
===================================================================
--- trunk/fellowiki/wiki/parser.py	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/wiki/parser.py	2006-06-09 18:02:06 UTC (rev 19)
@@ -29,18 +29,25 @@
 
 import elementtree.ElementTree as ElementTree
 from fellowiki.util.assorted import attributes_from_dict, \
-      remove_escaping_backslashes
+      remove_escaping_backslashes, remove_backslashes_and_whitespace
       
 import sre
 import re
-from copy import copy
+from copy import copy, deepcopy
 
 PREFIX_COUNT = "prefix count"
 ENCAPSULATE_MARKUP = "encapsulate markup"
 SWITCH_MARKUP = "switch markup"
 EMBED_MARKUP = "embed markup"
 
+SPLIT = 'split'
+ESCAPE = 'escape'
+DEFERRED = 'deferred'
+BLOCK_LEVEL = 'block level'
+PROC = 'procedure'
+MACRO = 'macro:'
 
+
 SPECIAL_MARKUP = {'/': ('em', 'italic'),
                   '*': ('b' , 'bold'),
                   '_': ('span', 'underlined'),
@@ -62,6 +69,7 @@
         self.content = []
         self.attributes = {}
         self.callback = []
+        self.translation = None
         
     def to_element_tree(self): 
         xhtml = ElementTree.Element(self.tag)
@@ -69,6 +77,7 @@
         xhtml.attrib = copy(self.attributes)
         current_textlist = []
         content = copy(self.content)
+        translations = []
         
         # I want to modify the list, therefore I write this a bit 
         # more explicitly:
@@ -86,14 +95,17 @@
                         xhtml.text = current_text
                     else:
                         sub_xhtml.tail = current_text
-                    sub_xhtml = item.to_element_tree()
+                    sub_xhtml, sub_translations = item.to_element_tree()
                     xhtml.append(sub_xhtml)
+                    translations.extend(sub_translations)
         current_text = ''.join(current_textlist)
         if sub_xhtml is None:
             xhtml.text = current_text
         else:
             sub_xhtml.tail = current_text
-        return xhtml
+        if self.translation is not None:
+            translations.append((xhtml, self.translation[0], self.translation[1]))
+        return xhtml, translations
         
     def is_empty(self):
         return len(self.content) == 0
@@ -139,7 +151,7 @@
     def close_matching(self, match):
         return False
     
-    def evaluate(self, result, tokens, state):
+    def evaluate(self, result, tokens, state, procs):
         self.result = result
         self.tokens = tokens
         self.state = state
@@ -186,7 +198,7 @@
     def append(self, *appendee):
         self.xhtml.append(*appendee)
     
-    def prepend_element_contents(self, element): 
+    def prepend_element_contents(self, element):
         self.xhtml.prepend(*element.content)
         
     def append_element_contents(self, element): 
@@ -215,8 +227,8 @@
         new_token.prepend(text)
 
 class WhitespaceToken(TextToken):
-    def evaluate(self, result, tokens, state):
-        TextToken.evaluate(self, result, tokens, state)
+    def evaluate(self, result, tokens, state, procs):
+        TextToken.evaluate(self, result, tokens, state, procs)
         for key in SPECIAL_MARKUP.keys():
             state[SWITCH_MARKUP + key] = 0
         
@@ -226,8 +238,8 @@
             self.state[self.STATE] = self.state.get(self.STATE, 0) - 1
         Token.render(self, new_token)
     
-    def evaluate(self, result, tokens, state):
-        Token.evaluate(self, result, tokens, state)
+    def evaluate(self, result, tokens, state, procs):
+        Token.evaluate(self, result, tokens, state, procs)
         if self.type == '(':
            state[self.STATE] = state.get(self.STATE, 0) + 1
         
@@ -272,8 +284,8 @@
         self.STATE = SWITCH_MARKUP + self.text
         self.EMBED = EMBED_MARKUP + self.text
     
-    def evaluate(self, result, tokens, state):
-        Token.evaluate(self, result, tokens, state)
+    def evaluate(self, result, tokens, state, procs):
+        Token.evaluate(self, result, tokens, state, procs)
         state[self.STATE] = state.get(self.STATE, 0) + 1
 
     def match_is_open(self):
@@ -309,12 +321,12 @@
     def render(self, new_token):
         new_token.prepend(' ')
         
-    def evaluate(self, result, tokens, state):
+    def evaluate(self, result, tokens, state, procs):
         if type(self) == type(tokens[0]) == LineBreakToken:
             next_token = tokens.pop(0)
             tokens.insert(0, ParagraphToken(self.token + next_token.token))
         else:
-            Token.evaluate(self, result, tokens, state)
+            Token.evaluate(self, result, tokens, state, procs)
     
     def match_is_open(self):
         return self.state.get(PREFIX_COUNT, 0) > 0
@@ -332,14 +344,14 @@
     def render(self, new_token):
         xhtml = XMLElement('br')
         new_token.prepend(xhtml)
-    def evaluate(self, result, tokens, state):
+    def evaluate(self, result, tokens, state, procs):
         while type(tokens[0]) == LineBreakToken:
             next_token = tokens.pop(0)
             self.token += next_token.token
         while len(result) >0 and type(result[-1]) == LineBreakToken:
             previous_result = result.pop()
             self.token = previous_result.token + self.token
-        LineBreakToken.evaluate(self, result, tokens, state)
+        LineBreakToken.evaluate(self, result, tokens, state, procs)
         
 class ParagraphToken(LineBreakOutputToken):
     def __init__(self, token, *args, **kwargs):
@@ -398,9 +410,9 @@
         self.has_been_prefixed = False
         Token.__init__(self, token, *args, **kwargs)
         
-    def evaluate(self, result, tokens, state):
+    def evaluate(self, result, tokens, state, procs):
         state[PREFIX_COUNT] = state.get(PREFIX_COUNT, 0) + 1
-        Token.evaluate(self, result, tokens, state)
+        Token.evaluate(self, result, tokens, state, procs)
         
     def render(self, new_token):
         self.state[PREFIX_COUNT] = self.state.get(PREFIX_COUNT, 0) - 1
@@ -475,12 +487,64 @@
     def render(self, new_token):
         PrefixToken.render(self, new_token)
         
+class MacroToken(Token): 
+    def render(self, new_token):
+        xhtml = XMLElement('span')
+        xhtml.append(self.text)
+        
+        if self.proc is not None:
+            xhtml.translation = (self.proc, self.parameter)
+            xhtml.attributes['class'] = 'macro_resolved'
+            xhtml.append(' --> "%s(%s)"' % (self.proc, unicode(self.parameter)))
+        else:
+            xhtml.attributes['class'] = 'macro_unresolved'
+            
+        new_token.prepend(xhtml)
+        
+    def evaluate(self, result, tokens, state, procs):
+        Token.evaluate(self, result, tokens, state, procs)
+        
+        self.proc = None
+        self.parameter = []
+        
+        match_obj = re.match(r'\{\{(([^\\\}\n\|]|\\.|\}[^\\\}\n\|]|\}\\.)*)' \
+                             r'\|(([^\\\}\n]|\\.|\}[^\\\}\n]|\}\\.)*)\}\}', 
+                             self.text)
+                             
+        
+        if match_obj:
+            command, _, parms, _ = match_obj.groups()
+        else:
+            command = self.text[2:-2]
+            parms = None
+             
+        command = '%s%s' % (MACRO, remove_backslashes_and_whitespace(command))
+        
+        try:
+            this_proc = procs[command]
+        except KeyError:
+            return
+        
+        self.proc = command
+        
+        if parms is not None:
+            if this_proc.get(SPLIT) is True:
+                if this_proc.get(ESCAPE) is True:
+                    self.parameter = [remove_backslashes_and_whitespace(par[0]) for 
+                            par in re.findall(r'(([^\\,]|\\.)+)(?=|,)', parms)]
+                else:
+                    self.parameter = [par[0] for 
+                            par in re.findall(r'(([^\\,]|\\.)+)(?=|,)', parms)]
+            else:
+                if this_proc.get(ESCAPE) is True:
+                    self.parameter = [remove_backslashes_and_whitespace(parms)]
+                else:
+                    self.parameter = [parms]
+            
 class LinkToken(Token): 
     pass
 class EmbeddedLinkToken(LinkToken): 
     pass
-class MacroToken(LinkToken): 
-    pass
 class TableToken(Token): 
     pass
 
@@ -541,8 +605,8 @@
                     preference=0)),
               (90, r'\|', token_factory(TableToken, type='_', preference=0)),
               # macros
-              (10, r'\{\{', token_factory(MacroToken, type='(', preference=20)),
-              (10, r'\}\}', token_factory(MacroToken, type=')', preference=20)),
+              (10, r'\{\{([^\\\}\n]|\\.|\}[^\\\}\n]|\}\\.)*\}\}', 
+                    token_factory(MacroToken, preference=20)),
               # n-dash and m-dash
               (20, r'----+', token_factory(TextToken)),
               (21, r'---', token_factory(TextToken, new_text=u'\u2014')),
@@ -555,11 +619,12 @@
               (99, r'.', token_factory(TextToken))
               ]
 
-    def __init__(self):
+    def __init__(self, procs):
         regexes = self.regexes[:]
         regexes.sort()
         regexes = [(rex, callback) for (_, rex, callback) in regexes]
         self.scanner = sre.Scanner(regexes, sre.M)
+        self.procs = procs
 
     def parse(self, text):
         tokens = self.scanner.scan(''.join(['\n\n', text, '\n\n']))
@@ -574,7 +639,7 @@
         
         while len(tokens) > 0:
             token = tokens.pop(0)
-            token.evaluate(result, tokens, state)
+            token.evaluate(result, tokens, state, self.procs)
         
         if len(tokens) != 0:
             raise WikiParserError('WikiParser error in "%s"' % text)
@@ -582,10 +647,18 @@
             raise WikiParserError('WikiParser error in "%s"' % text)
             
         if len(result) == 1:    
-            xhtml_tree = result[0].xhtml.to_element_tree()
+            xhtml_tree, translations = result[0].xhtml.to_element_tree()
+            
         else:
             xhtml_tree = ElementTree.Element('div')
+            translations = []
         
         xhtml_tree.set('class','parsed-wiki-content')
         
-        return xhtml_tree
+        return (xhtml_tree, translations)
+        
+    def evaluate(self, tree):
+        tree_  = deepcopy(tree)
+        for trans in tree_[1]:
+            self.procs[trans[1]][PROC](trans[0], *trans[2])
+        return tree[0]

Copied: trunk/fellowiki/wiki/tests (from rev 18, trunk/fellowiki/tests/wiki)

Deleted: trunk/fellowiki/wiki/tests/tests/simple_markup/macros.wiki
===================================================================
--- trunk/fellowiki/tests/wiki/tests/simple_markup/macros.wiki	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros.wiki	2006-06-09 18:02:06 UTC (rev 19)
@@ -1 +0,0 @@
-TODO

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki
===================================================================
--- trunk/fellowiki/tests/wiki/tests/simple_markup/macros_different_configs.wiki	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki	2006-06-09 18:02:06 UTC (rev 19)
@@ -0,0 +1,9 @@
+{{ testmacro | 12\ , ab\,cd,ef , \ gh }}
+
+{{ macro ohne split | 12\ , ab\,cd,ef , \ gh }}
+
+{{ macro ohne escape | 12\ , ab\,cd,ef , \ gh }}
+
+{{ macro ohne s/e | 12\ , ab\,cd,ef , \ gh }}
+
+TODO: weitere Configs: block level und deferred

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_invalid.wiki
===================================================================
--- trunk/fellowiki/tests/wiki/tests/simple_markup/macros_invalid.wiki	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_invalid.wiki	2006-06-09 18:02:06 UTC (rev 19)
@@ -0,0 +1,7 @@
+{testmacro}
+{{no macro}}
+{{ no macro | 1, 2, 3 }}
+\{{testmacro}}
+{\{testmacro}}
+{{testmacro\}}
+{{testmacro}\}

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_simple.wiki
===================================================================
--- trunk/fellowiki/tests/wiki/tests/simple_markup/macros_simple.wiki	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_simple.wiki	2006-06-09 18:02:06 UTC (rev 19)
@@ -0,0 +1,2 @@
+{{testmacro}} {{ test macro2 }} {{Test: -Macro3-}} 
+{{{testmacro}}}

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_escapes.wiki
===================================================================
--- trunk/fellowiki/tests/wiki/tests/simple_markup/macros_with_escapes.wiki	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_escapes.wiki	2006-06-09 18:02:06 UTC (rev 19)
@@ -0,0 +1,2 @@
+{{ test macro \| 11\ | 12 | 13 | 14, 15\, 16,\ 17}} {{ test macro \\ }} {{ test macro \\\ }} {{ test macro \\\\ }} {{ test macro \\\\\ }} {{testmacro | a\ }} {{testmacro | a\\ }} {{testmacro | a\\\ }} {{testmacro | a\\\\ }} {{testmacro | a\\\\\ }}
+{{\{testmacro\}}}

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_parms.wiki
===================================================================
--- trunk/fellowiki/tests/wiki/tests/simple_markup/macros_with_parms.wiki	2006-04-02 23:03:18 UTC (rev 18)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_parms.wiki	2006-06-09 18:02:06 UTC (rev 19)
@@ -0,0 +1 @@
+{{testmacro4|parm}} {{testmacro5 | parm }} {{ testmacro6 | parm1, parm2}} {{testmacro7 | parameter 1 , parameter 2 }} {{testmacro8 | 123, 456.789}} {{testmacro9|a,b,c,d,e}} {{ test macro 10 | 1, 2, 3, 4.56 }} 



From fingerle at berlios.de  Fri Jun  9 20:12:05 2006
From: fingerle at berlios.de (fingerle at BerliOS)
Date: Fri, 9 Jun 2006 20:12:05 +0200
Subject: [fellowiki-svncheckins] r20 - trunk/fellowiki/wiki/tests
Message-ID: <200606091812.k59IC54E030551@sheep.berlios.de>

Author: fingerle
Date: 2006-06-09 20:11:59 +0200 (Fri, 09 Jun 2006)
New Revision: 20

Added:
   trunk/fellowiki/wiki/tests/test_parser.py
Removed:
   trunk/fellowiki/wiki/tests/ut_parser.py
Log:
cleaning up unfinished checkin 19


Added: trunk/fellowiki/wiki/tests/test_parser.py
===================================================================
--- trunk/fellowiki/wiki/tests/test_parser.py	2006-06-09 18:02:06 UTC (rev 19)
+++ trunk/fellowiki/wiki/tests/test_parser.py	2006-06-09 18:11:59 UTC (rev 20)
@@ -0,0 +1,240 @@
+# pylint: disable-msg=W0702,W0706
+# W0702, W0706: allow exception handling scheme in new_test_func
+
+# Copyright (c) 2006 Jan Niklas Fingerle
+# 
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+# DEALINGS IN THE SOFTWARE.
+
+# XHTML validating inspired by Cookbook, recipe 12.8 TODO: elaborate
+
+"""unit tests for the classmates wiki parser
+
+wer're using nosetests
+"""
+
+import unittest
+import codecs
+import sys
+
+from os.path import dirname, isdir, splitext, join, abspath, basename
+from os import listdir
+from copy import copy
+from elementtree.ElementTree import tostring, fromstring, Element, SubElement
+from xml.parsers.xmlproc import xmlval, utils, xmldtd
+
+from fellowiki.wiki.parser import WikiParser, SPLIT, ESCAPE, PROC, MACRO, \
+                                  DEFERRED, BLOCK_LEVEL
+
+# Pre-load the xhtml DTD once, since reloading for each xmlproc
+# would be a major performance hit.
+_xhtml_dtd = xmldtd.load_dtd(join(dirname(abspath(__file__)), '..', '..',
+                                  'third_party', 'w3c', 'xhtml1-strict.dtd'))
+
+def _assert_etrees(etree_1, etree_2):
+    """assert that two ElementTrees are equal
+    
+    parameters: etree_1, 
+                etree2:  two ElementTrees
+    
+    """
+    
+    assert etree_1.tag == etree_2.tag
+    assert etree_1.text == etree_2.text
+    assert etree_1.tail == etree_2.tail
+    assert etree_1.attrib == etree_2.attrib
+    
+    children_1 = etree_1.getchildren()
+    children_2 = etree_2.getchildren()
+    
+    assert len(children_1) == len(children_2)
+    for (child_1, child_2) in zip(children_1, children_2):
+        _assert_etrees(child_1, child_2)    
+
+
+def _macro_test_proc(macro_name):
+    def new_test_proc(element, *args):
+        element.tag = 'span'
+        element.attrib = {'class': 'test_macro_class'}
+        element.text = '{MACRO %s: %s}' % (macro_name, unicode(args))
+    return new_test_proc
+
+procs = {'macro ohne split': {PROC: _macro_test_proc('kein split'),
+                              ESCAPE: True},
+         'macro ohne escape': {PROC: _macro_test_proc('kein escape'),
+                               SPLIT: True},
+         'macro ohne s/e': {PROC: _macro_test_proc('kein split, escape')},
+         'macro deferred': {PROC: _macro_test_proc('deferred'),
+                            SPLIT: True,
+                            ESCAPE: True,
+                            DEFERRED: True},
+         'macro block level': {PROC: _macro_test_proc('block level'),
+                               SPLIT: True,
+                               ESCAPE: True,
+                               BLOCK_LEVEL: True},
+         'macro b/l, def': {PROC: _macro_test_proc('block level, deferred'),
+                            SPLIT: True,
+                            ESCAPE: True,
+                            DEFERRED: True,
+                            BLOCK_LEVEL: True}}
+
+for (num, name) in enumerate(['testmacro', 'test macro2', 'Test: -Macro3-',
+                              'testmacro4', 'testmacro5', 'testmacro6',
+                              'testmacro7', 'testmacro8', 'testmacro9',
+                              'test macro 10', 'test macro | 11 ',
+                              'test macro \\', 'test macro \\ ',
+                              'test macro \\\\', 'test macro \\\\ ']):
+    procs[MACRO + name] = {PROC: _macro_test_proc('testmacro %i' % num),
+                           SPLIT: True,
+                           ESCAPE: True}
+
+
+procs2 = copy(procs)
+
+procs2['macro deferred'] = {PROC: _macro_test_proc('DEFERRED'),
+                            SPLIT: True,
+                            ESCAPE: True,
+                            DEFERRED: True}
+                                
+procs2['macro b/l, def'] = {PROC: _macro_test_proc('DEFERRED and block level'),
+                            SPLIT: True,
+                            ESCAPE: True,
+                            DEFERRED: True,
+                            BLOCK_LEVEL: True}
+
+#set up wiki parser
+parser = WikiParser(procs = procs)
+parser2 = WikiParser(procs = procs2)
+
+def wiki_ut(fname, tc_extension):
+    """test translation of one wiki markup string
+    
+    parameters: fname: file name, see below
+                tc_extension: test case extension name, see below
+    returns: nothing
+    throws: whatever exceptions occur during parsing of the wiki text
+            and exceptions used by the unittest framework to signal 
+            test failure
+    
+    The function parses the file <fname>.wiki and compares the result to 
+    the content of <fname>.<tc_extension>.xml. 
+    
+    If the unit test fails (but not in case of errors), an attempt is 
+    made, to write <fname>.<tc_extension>.generated.xml. If this write 
+    attempt fails, it does so silently. 
+    In any case the original fail or error (that occured before the 
+    writing attempt) will be raised to the caller (i.e. the unit test 
+    "test runner").
+    
+    """
+    
+    
+    # unfortunately I need a new validator each time around (Bug in 
+    # xmlval: part of the old file remains in the buffer)
+    xhtml_validator = xmlval.XMLValidator()
+    xhtml_validator.set_error_handler(utils.ErrorRaiser(xhtml_validator))
+    xhtml_validator.val.dtd = xhtml_validator.dtd = \
+                                   xhtml_validator.ent = _xhtml_dtd
+    try:
+        # parse wiki text to XML tree
+        wiki_file = codecs.open('%s.wiki' % fname, 'r', 'utf8')
+        wiki_text = wiki_file.read()
+        wiki_file.close()
+        parsed_content = parser.parse(wiki_text)
+        xhtml_tree_wiki = parser2.evaluate(parsed_content)
+        
+        # 'extend' tree to a complete XML tree
+        xhtml_tree_wiki_ext = Element('html', 
+                                      xmlns='http://www.w3.org/1999/xhtml')
+        head = SubElement(xhtml_tree_wiki_ext,'head')
+        SubElement(head,'title')
+        body = SubElement(xhtml_tree_wiki_ext,'body')
+        body.append(xhtml_tree_wiki)
+        
+        # do one 'round trip' to get a canonical form
+        xhtml_text_wiki_ext = tostring(xhtml_tree_wiki_ext)
+        xhtml_tree_wiki_ext_cononical = fromstring(xhtml_text_wiki_ext)
+        
+        # read expected XML tree from file
+        try:
+            xhtml_fn = '%s.%s.xml' % (fname, tc_extension)
+            xhtml_file = codecs.open(xhtml_fn, 'r', 'utf8')
+            xhtml_text = xhtml_file.read()
+            xhtml_file.close()
+        except IOError:
+            raise AssertionError('could not open file %s' % xhtml_fn)
+        xhtml_tree = fromstring(xhtml_text)
+        
+        # and now for the tests
+        _assert_etrees(xhtml_tree, xhtml_tree_wiki_ext_cononical)
+        xhtml_validator.parse_resource(xhtml_fn) # validate as XHTML
+        
+    except AssertionError, ex_val:
+        # I want to re-raise *this* exception with full traceback, even if I
+        # get another one inbetween
+        ex_tb = sys.exc_info()[-1]
+        try:
+            gen_file = codecs.open('%s.%s.generated.xml' % 
+                         (fname, tc_extension), 'w+','utf8')
+            gen_file.write(xhtml_text_wiki_ext)
+            gen_file.close()
+        except:
+            pass # it's only debug output after all
+        raise AssertionError, ex_val, ex_tb 
+
+
+def make_ut_wiki(tc_extension, tc_path = 
+                 join(dirname(abspath(__file__)),'tests'), **kwargs):
+    """generate wiki test cases
+    
+    parameters: tc_extension: extension for XML file names ("<fname>.wiki" will
+                              be compared to <fname>.<tc_extension>.xml)
+                tc_path:      directory, where to look for *.wiki and *.xml 
+                              files. Defaults to subdirectory "tests" of the 
+                              directory where this file is located.
+                **kwargs:     Any additional keyword arguments are passed to 
+                              the wiki parser's __init__() method.
+    returns: an instance of unittest.TestSuite
+    throws: nothing to be expected
+     
+    Test cases and test suites are generated "the normal way" from classes. 
+    Therefore the test case classes must be generated dynamically. In the end
+    the internal structure of the test suites is more like normal test cases
+    than if we had built the suites ourselves.
+       
+    """
+        
+    # find test files and subdirectories
+    fnames = listdir(tc_path)
+    fnames = [file_ for file_ in fnames if file_[0:1] != '.'] # no hidden files
+    fnames = [join(tc_path, file_) for file_ in fnames] 
+    files = [splitext(file_)[0] for file_ in fnames 
+                                               if splitext(file_)[1] == '.wiki']
+    dirs = [file_ for file_ in fnames if isdir(file_)]
+    
+    # for every *.wiki file generate a test method
+    for file_ in files:
+        yield wiki_ut, file_, tc_extension
+    
+    for dir_ in dirs:
+        for tc in make_ut_wiki(tc_extension, tc_path = dir_):
+            yield tc
+    
+def test_parser():
+    for tc in make_ut_wiki('complete'):
+        yield tc

Deleted: trunk/fellowiki/wiki/tests/ut_parser.py
===================================================================
--- trunk/fellowiki/wiki/tests/ut_parser.py	2006-06-09 18:02:06 UTC (rev 19)
+++ trunk/fellowiki/wiki/tests/ut_parser.py	2006-06-09 18:11:59 UTC (rev 20)
@@ -1,236 +0,0 @@
-# pylint: disable-msg=W0702,W0706
-# W0702, W0706: allow exception handling scheme in new_test_func
-
-# Copyright (c) 2006 Jan Niklas Fingerle
-# 
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-# XHTML validating inspired by Cookbook, recipe 12.8 TODO: elaborate
-
-"""unit tests for the classmates wiki parser
-
-The unit test suite  for the classmates wiki parser is made available through 
-the "suite()" function.
-    
-The function "make_wiki_test_suite()" may be used to implement unit test for 
-extensions to the classmates wiki parser.
-
-"""
-
-import unittest
-import codecs
-import sys
-
-from os.path import dirname, isdir, splitext, join, abspath, basename
-from os import listdir
-from elementtree.ElementTree import tostring, fromstring, Element, SubElement
-from xml.parsers.xmlproc import xmlval, utils, xmldtd
-
-from fellowiki.wiki.parser import WikiParser
-
-# Pre-load the xhtml DTD once, since reloading for each xmlproc
-# would be a major performance hit.
-_xhtml_dtd = xmldtd.load_dtd(join(dirname(abspath(__file__)), '..', '..',
-                                  'third_party', 'w3c', 'xhtml1-strict.dtd'))
-    
-def _make_new_test_func(fname, tc_extension):
-    """generate a new test function to be used in our unit tests
-    
-    parameters: fname:        fully qualified filename, but without file 
-                              extension, to generate the test case from
-                tc_extension: extension name of the test case, refer to 
-                              new_test_func for exact desciption
-    returns: test function for the new test case. The test funcion takes
-             one argument, self, and is to be used as a method of WikiTestCase.
-    throws: nothing to be expected
-
-    The returned test function is always "the same", with the one exception
-    that it uses different "fname" and "tc_extension" values (i.e. it's a
-    closure).
-
-    """
-
-    def new_test_func(self):
-        """test translation of one wiki markup string
-        
-        parameters: self: instance of WikiTestCase
-        returns: nothing
-        throws: whatever exceptions occur during parsing of the wiki text
-                and exceptions used by the unittest framework to signal 
-                test failure
-        bound to (closure): "fname" and "tc_extension" from the surrounding 
-                            scope
-        
-        The function parses the file <fname>.wiki and compares the result to 
-        the content of <fname>.<tc_extension>.xml. 
-        
-        If the unit test fails (but not in case of errors), an attempt is 
-        made, to write <fname>.<tc_extension>.generated.xml. If this write 
-        attempt fails, it does so silently. 
-        In any case the original fail or error (that occured before the 
-        writing attempt) will be raised to the caller (i.e. the unit test 
-        "test runner").
-        
-        """
-        
-        try:
-            # parse wiki text to XML tree
-            wiki_file = codecs.open('%s.wiki' % fname, 'r', 'utf8')
-            wiki_text = wiki_file.read()
-            wiki_file.close()
-            xhtml_tree_wiki = self.parser.parse(wiki_text)
-            
-            # 'extend' tree to a complete XML tree
-            xhtml_tree_wiki_ext = Element('html', 
-                                          xmlns='http://www.w3.org/1999/xhtml')
-            head = SubElement(xhtml_tree_wiki_ext,'head')
-            SubElement(head,'title')
-            body = SubElement(xhtml_tree_wiki_ext,'body')
-            body.append(xhtml_tree_wiki)
-            
-            # do one 'round trip' to get a canonical form
-            xhtml_text_wiki_ext = tostring(xhtml_tree_wiki_ext)
-            xhtml_tree_wiki_ext_cononical = fromstring(xhtml_text_wiki_ext)
-            
-            # read expected XML tree from file
-            try:
-                xhtml_fn = '%s.%s.xml' % (fname, tc_extension)
-                xhtml_file = codecs.open(xhtml_fn, 'r', 'utf8')
-                xhtml_text = xhtml_file.read()
-                xhtml_file.close()
-            except IOError:
-                self.fail('Could not open XML file "%s"' % xhtml_fn)
-            xhtml_tree = fromstring(xhtml_text)
-            
-            # and now for the tests
-            self._assert_etrees(xhtml_tree, xhtml_tree_wiki_ext_cononical)
-            self.xhtml_validator.parse_resource(xhtml_fn) # validate as XHTML
-            
-        except self.failureException, ex_val:
-            # I want to re-raise *this* exception with full traceback, even if I
-            # get another one inbetween
-            ex_tb = sys.exc_info()[-1]
-            try:
-                gen_file = codecs.open('%s.%s.generated.xml' % 
-                             (fname, tc_extension), 'w+','utf8')
-                gen_file.write(xhtml_text_wiki_ext)
-                gen_file.close()
-            except:
-                pass # it's only debug output after all
-            raise self.failureException, ex_val, ex_tb 
-    return new_test_func
-    
-def make_wiki_test_suite(tc_extension, 
-                         tc_name = None, tc_path = 
-                         join(dirname(abspath(__file__)),'tests'), **kwargs):
-    """generate a new wiki test suite for unit testing
-    
-    parameters: tc_extension: extension for XML file names ("<fname>.wiki" will
-                              be compared to <fname>.<tc_extension>.xml)
-                tc_name:      suffix for the test case classes name (will be
-                              "WikiTestCase_<tc_name>"). If None (default), 
-                              tc_extension will be used.
-                tc_path:      directory, where to look for *.wiki and *.xml 
-                              files. Defaults to subdirectory "tests" of the 
-                              directory where this file is located.
-                **kwargs:     Any additional keyword arguments are passed to 
-                              the wiki parser's __init__() method.
-    returns: an instance of unittest.TestSuite
-    throws: nothing to be expected
-     
-    Test cases and test suites are generated "the normal way" from classes. 
-    Therefore the test case classes must be generated dynamically. In the end
-    the internal structure of the test suites is more like normal test cases
-    than if we had built the suites ourselves.
-       
-    """
-    
-    if tc_name == None:
-        tc_name = tc_extension        
-    
-    class WikiTestCase(unittest.TestCase):
-        """test case for the wiki parser"""
-        
-        def _assert_etrees(self, etree_1, etree_2):
-            """assert that two ElementTrees are equal
-            
-            parameters: self:    instance of subclass of unittest.TestCase
-                        etree_1, 
-                        etree2:  two ElementTrees
-            
-            """
-            
-            self.assertEqual(etree_1.tag, etree_2.tag)
-            self.assertEqual(etree_1.text, etree_2.text)
-            self.assertEqual(etree_1.tail, etree_2.tail)
-            self.assertEqual(etree_1.attrib, etree_2.attrib)
-            
-            children_1 = etree_1.getchildren()
-            children_2 = etree_2.getchildren()
-            
-            self.assertEqual(len(children_1), len(children_2))
-            for (child_1, child_2) in zip(children_1, children_2):
-                self._assert_etrees(child_1, child_2)
-                
-        def setUp(self): 
-            """set up wiki parser and xhtml validator"""
-            self.parser = WikiParser(**kwargs)
-            # unfortunately I need a new validator each time around (Bug in 
-            # xmlval: part of the old file remains in the buffer)
-            self.xhtml_validator = xmlval.XMLValidator()
-            self.xhtml_validator.set_error_handler(utils.ErrorRaiser(
-                                                          self.xhtml_validator))
-            self.xhtml_validator.val.dtd = self.xhtml_validator.dtd = \
-                                           self.xhtml_validator.ent = _xhtml_dtd
-        
-    WikiTestCase.__name__ = 'WikiTestCase_%s' % tc_name
-    
-    # find test files and subdirectories
-    fnames = listdir(tc_path)
-    fnames = [file_ for file_ in fnames if file_[0:1] != '.'] # no hidden files
-    fnames = [join(tc_path, file_) for file_ in fnames] 
-    files = [splitext(file_)[0] for file_ in fnames 
-                                               if splitext(file_)[1] == '.wiki']
-    dirs = [file_ for file_ in fnames if isdir(file_)]
-    
-    # for every *.wiki file generate a test method
-    for file_ in files:
-        new_test_func = _make_new_test_func(file_, tc_extension)
-        new_test_func.__doc__ = "wiki parser: %s - %s" % \
-                                                      (tc_name, basename(file_))
-        new_test_func.__name__ = tf_name = "test_%s" % basename(file_)
-        setattr(WikiTestCase, tf_name, new_test_func)
-    
-    # generate test suite and add sub-test-suites
-    suite_ = unittest.makeSuite(WikiTestCase)
-    for dir_ in dirs:
-        suite_.addTest(make_wiki_test_suite(tc_extension, 
-                                           tc_name = '%s_%s' %
-                                                      (tc_name, basename(dir_)),
-                                           tc_path = dir_, 
-                                           **kwargs))
-    
-    return suite_
-    
-def suite():
-    """return default unit test suite for this module"""
-    return make_wiki_test_suite('complete')
-
-if __name__ == '__main__':
-    unittest.TextTestRunner(verbosity=2).run(suite())



From fingerle at berlios.de  Fri Jun  9 21:22:57 2006
From: fingerle at berlios.de (fingerle at BerliOS)
Date: Fri, 9 Jun 2006 21:22:57 +0200
Subject: [fellowiki-svncheckins] r21 - in trunk/fellowiki/wiki: . tests tests/tests/simple_markup
Message-ID: <200606091922.k59JMv7L029227@sheep.berlios.de>

Author: fingerle
Date: 2006-06-09 21:22:53 +0200 (Fri, 09 Jun 2006)
New Revision: 21

Modified:
   trunk/fellowiki/wiki/parser.py
   trunk/fellowiki/wiki/tests/test_parser.py
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki
Log:
- some more work on macros: deferred evaluation


Modified: trunk/fellowiki/wiki/parser.py
===================================================================
--- trunk/fellowiki/wiki/parser.py	2006-06-09 18:11:59 UTC (rev 20)
+++ trunk/fellowiki/wiki/parser.py	2006-06-09 19:22:53 UTC (rev 21)
@@ -104,7 +104,14 @@
         else:
             sub_xhtml.tail = current_text
         if self.translation is not None:
-            translations.append((xhtml, self.translation[0], self.translation[1]))
+            if self.translation[1] is None:
+                print 'deferred: %s' % self.translation[0]
+                translations.append((xhtml, 
+                                     self.translation[0], 
+                                     self.translation[2]))
+            else:
+                print 'not deferred: %s' % self.translation[0]
+                self.translation[1](xhtml,  self.translation[2])
         return xhtml, translations
         
     def is_empty(self):
@@ -493,7 +500,9 @@
         xhtml.append(self.text)
         
         if self.proc is not None:
-            xhtml.translation = (self.proc, self.parameter)
+            xhtml.translation = (self.proc, 
+                                 self.proc_not_deferred,
+                                 self.parameter)
             xhtml.attributes['class'] = 'macro_resolved'
             xhtml.append(' --> "%s(%s)"' % (self.proc, unicode(self.parameter)))
         else:
@@ -505,6 +514,7 @@
         Token.evaluate(self, result, tokens, state, procs)
         
         self.proc = None
+        self.proc_not_deferred = None
         self.parameter = []
         
         match_obj = re.match(r'\{\{(([^\\\}\n\|]|\\.|\}[^\\\}\n\|]|\}\\.)*)' \
@@ -528,18 +538,20 @@
         self.proc = command
         
         if parms is not None:
-            if this_proc.get(SPLIT) is True:
-                if this_proc.get(ESCAPE) is True:
+            if this_proc.get(SPLIT):
+                if this_proc.get(ESCAPE):
                     self.parameter = [remove_backslashes_and_whitespace(par[0]) for 
                             par in re.findall(r'(([^\\,]|\\.)+)(?=|,)', parms)]
                 else:
                     self.parameter = [par[0] for 
                             par in re.findall(r'(([^\\,]|\\.)+)(?=|,)', parms)]
             else:
-                if this_proc.get(ESCAPE) is True:
+                if this_proc.get(ESCAPE):
                     self.parameter = [remove_backslashes_and_whitespace(parms)]
                 else:
                     self.parameter = [parms]
+        if not this_proc.get(DEFERRED):
+            self.proc_not_deferred = this_proc[PROC]
             
 class LinkToken(Token): 
     pass
@@ -660,5 +672,6 @@
     def evaluate(self, tree):
         tree_  = deepcopy(tree)
         for trans in tree_[1]:
+            print 'translating deferred %s' % trans[1]
             self.procs[trans[1]][PROC](trans[0], *trans[2])
-        return tree[0]
+        return tree_[0]

Modified: trunk/fellowiki/wiki/tests/test_parser.py
===================================================================
--- trunk/fellowiki/wiki/tests/test_parser.py	2006-06-09 18:11:59 UTC (rev 20)
+++ trunk/fellowiki/wiki/tests/test_parser.py	2006-06-09 19:22:53 UTC (rev 21)
@@ -74,24 +74,27 @@
         element.text = '{MACRO %s: %s}' % (macro_name, unicode(args))
     return new_test_proc
 
-procs = {'macro ohne split': {PROC: _macro_test_proc('kein split'),
-                              ESCAPE: True},
-         'macro ohne escape': {PROC: _macro_test_proc('kein escape'),
-                               SPLIT: True},
-         'macro ohne s/e': {PROC: _macro_test_proc('kein split, escape')},
-         'macro deferred': {PROC: _macro_test_proc('deferred'),
-                            SPLIT: True,
-                            ESCAPE: True,
-                            DEFERRED: True},
-         'macro block level': {PROC: _macro_test_proc('block level'),
-                               SPLIT: True,
-                               ESCAPE: True,
-                               BLOCK_LEVEL: True},
-         'macro b/l, def': {PROC: _macro_test_proc('block level, deferred'),
-                            SPLIT: True,
-                            ESCAPE: True,
-                            DEFERRED: True,
-                            BLOCK_LEVEL: True}}
+procs = {MACRO + 'macro default': {PROC: _macro_test_proc('default macro'),
+                                   SPLIT: True,
+                                   ESCAPE: True},
+         MACRO + 'macro ohne split': {PROC: _macro_test_proc('kein split'),
+                                      ESCAPE: True},
+         MACRO + 'macro ohne escape': {PROC: _macro_test_proc('kein escape'),
+                                       SPLIT: True},
+         MACRO + 'macro ohne s/e': {PROC: _macro_test_proc('kein split, escape')},
+         MACRO + 'macro deferred': {PROC: _macro_test_proc('deferred'),
+                                    SPLIT: True,
+                                    ESCAPE: True,
+                                    DEFERRED: True},
+         MACRO + 'macro block level': {PROC: _macro_test_proc('block level'),
+                                       SPLIT: True,
+                                       ESCAPE: True,
+                                       BLOCK_LEVEL: True},
+         MACRO + 'macro b/l, def': {PROC: _macro_test_proc('block level, deferred'),
+                                    SPLIT: True,
+                                    ESCAPE: True,
+                                    DEFERRED: True,
+                                    BLOCK_LEVEL: True}}
 
 for (num, name) in enumerate(['testmacro', 'test macro2', 'Test: -Macro3-',
                               'testmacro4', 'testmacro5', 'testmacro6',
@@ -106,16 +109,20 @@
 
 procs2 = copy(procs)
 
-procs2['macro deferred'] = {PROC: _macro_test_proc('DEFERRED'),
-                            SPLIT: True,
-                            ESCAPE: True,
-                            DEFERRED: True}
+procs2[MACRO + 'macro default'] = {PROC: _macro_test_proc('default macro DEFERRED'),
+                                   SPLIT: True,
+                                   ESCAPE: True},
+
+procs2[MACRO + 'macro deferred'] = {PROC: _macro_test_proc('DEFERRED'),
+                                    SPLIT: True,
+                                    ESCAPE: True,
+                                    DEFERRED: True}
                                 
-procs2['macro b/l, def'] = {PROC: _macro_test_proc('DEFERRED and block level'),
-                            SPLIT: True,
-                            ESCAPE: True,
-                            DEFERRED: True,
-                            BLOCK_LEVEL: True}
+procs2[MACRO + 'macro b/l, def'] = {PROC: _macro_test_proc('DEFERRED and block level'),
+                                    SPLIT: True,
+                                    ESCAPE: True,
+                                    DEFERRED: True,
+                                    BLOCK_LEVEL: True}
 
 #set up wiki parser
 parser = WikiParser(procs = procs)

Modified: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki
===================================================================
--- trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki	2006-06-09 18:11:59 UTC (rev 20)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki	2006-06-09 19:22:53 UTC (rev 21)
@@ -1,9 +1 @@
-{{ testmacro | 12\ , ab\,cd,ef , \ gh }}
-
-{{ macro ohne split | 12\ , ab\,cd,ef , \ gh }}
-
-{{ macro ohne escape | 12\ , ab\,cd,ef , \ gh }}
-
-{{ macro ohne s/e | 12\ , ab\,cd,ef , \ gh }}
-
-TODO: weitere Configs: block level und deferred
+{{ macro default | 12\ , ab\,cd,ef , \ gh }} {{ macro ohne split | 12\ , ab\,cd,ef , \ gh }} {{ macro block level | 12\ , ab\,cd,ef , \ gh }} {{ macro ohne escape | 12\ , ab\,cd,ef , \ gh }} {{ macro ohne s/e | 12\ , ab\,cd,ef , \ gh }} {{ macro b/l, def | 12\ , ab\,cd,ef , \ gh }} {{ macro deferred | 12\ , ab\,cd,ef , \ gh }}



From fingerle at berlios.de  Sat Jun 10 12:19:08 2006
From: fingerle at berlios.de (fingerle at BerliOS)
Date: Sat, 10 Jun 2006 12:19:08 +0200
Subject: [fellowiki-svncheckins] r22 - in trunk/fellowiki/wiki: . tests tests/tests/simple_markup
Message-ID: <200606101019.k5AAJ8X4013203@sheep.berlios.de>

Author: fingerle
Date: 2006-06-10 12:19:08 +0200 (Sat, 10 Jun 2006)
New Revision: 22

Added:
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.complete.xml
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_invalid.complete.xml
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_simple.complete.xml
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_escapes.complete.xml
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_parms.complete.xml
Modified:
   trunk/fellowiki/wiki/parser.py
   trunk/fellowiki/wiki/tests/test_parser.py
   trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki
Log:
- wiki parser: finished macro handling


Modified: trunk/fellowiki/wiki/parser.py
===================================================================
--- trunk/fellowiki/wiki/parser.py	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/parser.py	2006-06-10 10:19:08 UTC (rev 22)
@@ -105,12 +105,10 @@
             sub_xhtml.tail = current_text
         if self.translation is not None:
             if self.translation[1] is None:
-                print 'deferred: %s' % self.translation[0]
                 translations.append((xhtml, 
                                      self.translation[0], 
                                      self.translation[2]))
             else:
-                print 'not deferred: %s' % self.translation[0]
                 self.translation[1](xhtml,  self.translation[2])
         return xhtml, translations
         
@@ -494,29 +492,30 @@
     def render(self, new_token):
         PrefixToken.render(self, new_token)
         
+        
+        
+##class HeadlineToken(PrefixToken): 
+##    def do_prefix(self, new_token):
+##        new_token.xhtml.tag = 'h%i' % (len(self.token) - 1)
+##        self.tokens.insert(0, BeetweenParagraphsXHTML(new_token.xhtml, 
+##                                                      self.token))
+        
 class MacroToken(Token): 
     def render(self, new_token):
-        xhtml = XMLElement('span')
-        xhtml.append(self.text)
+        if not self.block_level:
+            new_token.prepend(self.xhtml)
         
-        if self.proc is not None:
-            xhtml.translation = (self.proc, 
-                                 self.proc_not_deferred,
-                                 self.parameter)
-            xhtml.attributes['class'] = 'macro_resolved'
-            xhtml.append(' --> "%s(%s)"' % (self.proc, unicode(self.parameter)))
-        else:
-            xhtml.attributes['class'] = 'macro_unresolved'
-            
-        new_token.prepend(xhtml)
-        
     def evaluate(self, result, tokens, state, procs):
         Token.evaluate(self, result, tokens, state, procs)
         
         self.proc = None
         self.proc_not_deferred = None
         self.parameter = []
+        self.xhtml = XMLElement('span')
+        self.xhtml.append(self.text)
+        self.block_level = False
         
+        
         match_obj = re.match(r'\{\{(([^\\\}\n\|]|\\.|\}[^\\\}\n\|]|\}\\.)*)' \
                              r'\|(([^\\\}\n]|\\.|\}[^\\\}\n]|\}\\.)*)\}\}', 
                              self.text)
@@ -533,6 +532,7 @@
         try:
             this_proc = procs[command]
         except KeyError:
+            self.xhtml.attributes['class'] = 'macro_unresolved'
             return
         
         self.proc = command
@@ -553,6 +553,17 @@
         if not this_proc.get(DEFERRED):
             self.proc_not_deferred = this_proc[PROC]
             
+        self.xhtml.translation = (self.proc, 
+                                  self.proc_not_deferred,
+                                  self.parameter)
+        self.xhtml.attributes['class'] = 'macro_resolved'
+        
+        if this_proc.get(BLOCK_LEVEL):
+            self.block_level = True
+            self.xhtml.tag = 'p'
+            self.tokens.insert(0, BeetweenParagraphsXHTML(self.xhtml, self.token))
+            
+            
 class LinkToken(Token): 
     pass
 class EmbeddedLinkToken(LinkToken): 
@@ -672,6 +683,5 @@
     def evaluate(self, tree):
         tree_  = deepcopy(tree)
         for trans in tree_[1]:
-            print 'translating deferred %s' % trans[1]
             self.procs[trans[1]][PROC](trans[0], *trans[2])
         return tree_[0]

Modified: trunk/fellowiki/wiki/tests/test_parser.py
===================================================================
--- trunk/fellowiki/wiki/tests/test_parser.py	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/tests/test_parser.py	2006-06-10 10:19:08 UTC (rev 22)
@@ -69,19 +69,19 @@
 
 def _macro_test_proc(macro_name):
     def new_test_proc(element, *args):
-        element.tag = 'span'
-        element.attrib = {'class': 'test_macro_class'}
-        element.text = '{MACRO %s: %s}' % (macro_name, unicode(args))
+        element.text = None
+        xhtml = SubElement(element, 'span', {'class': 'test_macro_class'}) 
+        xhtml.text = '{MACRO %s: %s}' % (macro_name, unicode(args))
     return new_test_proc
 
 procs = {MACRO + 'macro default': {PROC: _macro_test_proc('default macro'),
                                    SPLIT: True,
                                    ESCAPE: True},
-         MACRO + 'macro ohne split': {PROC: _macro_test_proc('kein split'),
+         MACRO + 'macro no split': {PROC: _macro_test_proc('no split'),
                                       ESCAPE: True},
-         MACRO + 'macro ohne escape': {PROC: _macro_test_proc('kein escape'),
+         MACRO + 'macro no escape': {PROC: _macro_test_proc('no escape'),
                                        SPLIT: True},
-         MACRO + 'macro ohne s/e': {PROC: _macro_test_proc('kein split, escape')},
+         MACRO + 'macro w/o s/e': {PROC: _macro_test_proc('no split, escape')},
          MACRO + 'macro deferred': {PROC: _macro_test_proc('deferred'),
                                     SPLIT: True,
                                     ESCAPE: True,

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.complete.xml
===================================================================
--- trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.complete.xml	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.complete.xml	2006-06-10 10:19:08 UTC (rev 22)
@@ -0,0 +1 @@
+<html xmlns="http://www.w3.org/1999/xhtml"><head><title /></head><body><div class="parsed-wiki-content"><p><span class="macro_resolved"><span class="test_macro_class">{MACRO default macro: ([u'12 ', u'ab,cd', u'ef', u' gh'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO no split: ([u'12 , ab,cd,ef ,  gh'],)}</span></span> </p><p class="macro_resolved"><span class="test_macro_class">{MACRO block level: ([u'12 ', u'ab,cd', u'ef', u' gh'],)}</span></p><p> <span class="macro_resolved"><span class="test_macro_class">{MACRO no escape: ([u' 12\\ ', u' ab\\,cd', u'ef ', u' \\ gh '],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO no split, escape: ([u' 12\\ , ab\\,cd,ef , \\ gh '],)}</span></span> </p><p class="macro_resolved"><span class="test_macro_class">{MACRO DEFERRED and block level: (u'12 ', u'ab,cd', u'ef', u' gh')}</span></p><p> <span class="macro_resolved"><span class="test_macro_class">{MACRO DEFERRE!
 D: (u'12 ', u'ab,cd', u'ef', u' gh')}</span></span></p></div></body></html>
\ No newline at end of file

Modified: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki
===================================================================
--- trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_different_configs.wiki	2006-06-10 10:19:08 UTC (rev 22)
@@ -1 +1 @@
-{{ macro default | 12\ , ab\,cd,ef , \ gh }} {{ macro ohne split | 12\ , ab\,cd,ef , \ gh }} {{ macro block level | 12\ , ab\,cd,ef , \ gh }} {{ macro ohne escape | 12\ , ab\,cd,ef , \ gh }} {{ macro ohne s/e | 12\ , ab\,cd,ef , \ gh }} {{ macro b/l, def | 12\ , ab\,cd,ef , \ gh }} {{ macro deferred | 12\ , ab\,cd,ef , \ gh }}
+{{ macro default | 12\ , ab\,cd,ef , \ gh }} {{ macro no split | 12\ , ab\,cd,ef , \ gh }} {{ macro block level | 12\ , ab\,cd,ef , \ gh }} {{ macro no escape | 12\ , ab\,cd,ef , \ gh }} {{ macro w/o s/e | 12\ , ab\,cd,ef , \ gh }} {{ macro b/l, def | 12\ , ab\,cd,ef , \ gh }} {{ macro deferred | 12\ , ab\,cd,ef , \ gh }}

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_invalid.complete.xml
===================================================================
--- trunk/fellowiki/wiki/tests/tests/simple_markup/macros_invalid.complete.xml	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_invalid.complete.xml	2006-06-10 10:19:08 UTC (rev 22)
@@ -0,0 +1 @@
+<html xmlns="http://www.w3.org/1999/xhtml"><head><title /></head><body><div class="parsed-wiki-content"><p>{testmacro} <span class="macro_unresolved">{{no macro}}</span> <span class="macro_unresolved">{{ no macro | 1, 2, 3 }}</span> {{testmacro}} {{testmacro}} {{testmacro}} {{testmacro}}</p></div></body></html>
\ No newline at end of file

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_simple.complete.xml
===================================================================
--- trunk/fellowiki/wiki/tests/tests/simple_markup/macros_simple.complete.xml	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_simple.complete.xml	2006-06-10 10:19:08 UTC (rev 22)
@@ -0,0 +1 @@
+<html xmlns="http://www.w3.org/1999/xhtml"><head><title /></head><body><div class="parsed-wiki-content"><p><span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 0: ([],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 1: ([],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 2: ([],)}</span></span> <span class="macro_unresolved">{{{testmacro}}</span>}</p></div></body></html>
\ No newline at end of file

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_escapes.complete.xml
===================================================================
--- trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_escapes.complete.xml	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_escapes.complete.xml	2006-06-10 10:19:08 UTC (rev 22)
@@ -0,0 +1 @@
+<html xmlns="http://www.w3.org/1999/xhtml"><head><title /></head><body><div class="parsed-wiki-content"><p><span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 10: ([u'12 | 13 | 14', u'15, 16', u' 17'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 11: ([],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 12: ([],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 13: ([],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 14: ([],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 0: ([u'a '],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 0: ([u'a\\'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 0: ([u'a\\ '],)}</span></span> <span class="mac!
 ro_resolved"><span class="test_macro_class">{MACRO testmacro 0: ([u'a\\\\'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 0: ([u'a\\\\ '],)}</span></span> <span class="macro_unresolved">{{\{testmacro\}}}</span></p></div></body></html>
\ No newline at end of file

Added: trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_parms.complete.xml
===================================================================
--- trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_parms.complete.xml	2006-06-09 19:22:53 UTC (rev 21)
+++ trunk/fellowiki/wiki/tests/tests/simple_markup/macros_with_parms.complete.xml	2006-06-10 10:19:08 UTC (rev 22)
@@ -0,0 +1 @@
+<html xmlns="http://www.w3.org/1999/xhtml"><head><title /></head><body><div class="parsed-wiki-content"><p><span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 3: ([u'parm'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 4: ([u'parm'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 5: ([u'parm1', u'parm2'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 6: ([u'parameter 1', u'parameter 2'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 7: ([u'123', u'456.789'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 8: ([u'a', u'b', u'c', u'd', u'e'],)}</span></span> <span class="macro_resolved"><span class="test_macro_class">{MACRO testmacro 9: ([u'1', u'2', u'3', u'4.56'],)}</span></span></p></div></body></html>
\ No newline at end of file



